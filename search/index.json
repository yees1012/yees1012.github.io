[{"content":"欢迎来到我的博客，我会在博客中记录一些学习笔记、学习过程中遇到的bug以及解决方法、一些读后感\u0026hellip;\n当然，我也会记录一些生活中值得记录的瞬间 ~\n博客刚刚创建不久，所以暂时不会开通评论功能，大家如果有什么想和我分享的可以通过小红书找到我：8075894904\n该博客是通过hugo创建：hugo-theme-stack-stater\n","date":"2025-04-16T04:19:00Z","image":"https://yees.com/p/hello-world/cafe-road_hu_b557e4c36a04015b.jpg","permalink":"https://yees.com/p/hello-world/","title":"Welcome !!!"},{"content":"拉取 Jenkins 镜像 1 2 3 4 5 6 docker run -d --name jenkins \\ -v /var/run/docker.sock:/var/run/docker.sock \\ -v jenkins_home_local:/var/jenkins_home \\ -p 8080:8080 \\ -p 50000:50000 \\ jenkins/jenkins:lts 打开 Jenkins 网页 http://localhost:8080\n进入 Jenkins 容器，复制 cat /var/jenkins_home/secrets/initialAdminPassword 到网页中\n容器挂载宿主机 1 2 docker exec -u 0 -it jenkins bash chmod 777 /var/run/docker.sock /var/run/docker.sock 是 Docker 守护进程的 Unix 套接字文件，通常在宿主机上，而不是在 Docker 容器内部。如果你想让你的 Jenkins 容器可以与 Docker 守护进程通信，你需要在运行 Docker 容器时，将这个套接字文件挂载到容器中，并给予权限。（如果后续容器被删除，再更新时也需要进行此操作）\n安装插件 记得关掉 vpn\nNode：用于 npm Docker Kubernetes K8s Git 配置全局 Tools 配置 Node 要 New Item -\u0026gt; Freestyle Project 来安装\n配置 Docker 要设置环境变量\n配置 K8s 要进入 Jenkins 容器来进行安装，且需要凭据 Credentials\nhttps://blog.csdn.net/liuweiyizhu/article/details/109746681\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 pipeline { agent any stages { stage(\u0026#39;Hello\u0026#39;) { steps { // 下载 kubectl 二进制文件 sh \u0026#39;\u0026#39;\u0026#39; curl -LO \u0026#34;https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl\u0026#34; chmod +x kubectl mv kubectl /usr/local/bin/kubectl \u0026#39;\u0026#39;\u0026#39; // 验证 kubectl 安装成功 sh \u0026#39;kubectl version --client\u0026#39; } } } } 配置 Python 要进入 Jenkins 容器来进行安装\n","date":"2025-04-21T00:00:00Z","permalink":"https://yees.com/p/jenkins-%E9%85%8D%E7%BD%AE%E6%B5%81%E7%A8%8B/","title":"Jenkins 配置流程"},{"content":"Tomcat 配置流程 IDEA 2023\n下载 Tomcat https://tomcat.apache.org/download-90.cgi - Core64-bit Windows zip\n环境变量的配置 配置环境变量：CATALINA_HOME\n然后找到 Path 双击，然后 New 添加 %CATALINA_HOME%\\bin\nIDEA 中的配置 创建新项目\nName：填写项目名称 Location：选择项目存放位置 JDK：选择项目的 JDK 版本 点击 Create 创建项目\n打开 Add Framework Support 界面\n快捷键 Shift + Shift 打开搜索界面，勾上右上角的 Include non-project items ，搜索 Add Framework Support\n添加 Web 应用\n勾上 Web Application，然后勾上 Create web.xml，最后点击 OK\nEdit Configuration\n点击右上角的 Current File，选择 Edit Configuration\n配置 Tomcat\n点击左上角的 + 号，找到 Tomcat Server 下的 Local\nServer 板块的设置\n在 Open browser 下面有一个可以选择 After launch 默认打开的浏览器，选择自己要使用的浏览器\nDeployment 板块的设置\n点击左上角的 + 号，选择 Artifact...\n设置默认路径\n在下方的 Application context 可以设置默认路径，每次要打开我们的网页的根路径就是这个。然后点击 Apply ， OK\n","date":"2025-04-21T00:00:00Z","permalink":"https://yees.com/p/tomcat-%E9%85%8D%E7%BD%AE%E6%B5%81%E7%A8%8B/","title":"Tomcat 配置流程"},{"content":" settings 搜索 variable，选择 Edit the system environment variables\n点击 Environment Variables\n点击 New 添加环境变量，然后点击 OK ， Apply\n","date":"2025-04-21T00:00:00Z","permalink":"https://yees.com/p/%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/","title":"配置环境变量"},{"content":"一面 算法：翻转链表 解法：一个数组存储然后反向遍历构成新链表【空间复杂度 O(n) 】；链表下一个指针指向前一个\nJVM 的内存结构 怎么判断一个对象是否可以被回收？ 垃圾收集器有哪些？ 垃圾回收算法有什么？ redis用在项目的哪里？ redis的底层逻辑是什么？ 说一下多路复用是什么？ 线程池有哪些核心参数？ 怎么设置线程池的核心参数？ 介绍SpringIOC的原理 介绍SpringAOP的原理 Spring、SpringMVC、SpringBoot的区别是什么？ 介绍mysql的索引 mysql的隔离级别是什么？ 访问百度整个流程是什么？ 如果访问一个网站一直转圈圈你会怎么排查？ tcp 和 udp的区别 tcp 粘包怎么解决？ 平时怎么学习新技术？ 会大模型吗？ 二面 项目：\n文献表的mysql字段怎么设计？ 用到什么索引？ redis的用意是什么？ 为什么要用es？（不是因为es比mysql更快） mysql事务并发题：说说 Q1-Q4 是怎么执行的？Q4 查询的时候 b 是多少？\n表：\na b c 1 1 1 隔离级别：可重复读\n1 2 3 4 5 6 7 8 9 10 t1 start t2 start t1: UPDATE 表 SET b=b+1 WHERE a=1; // Q1 t2: UPDATE 表 SET b=b+1 WHERE a=1; // Q2 t1 submit t2: UPDATE 表 SET b=b+1 WHERE a=1; // Q3 t3 start t3: SELECT * FROM 表 WHERE b=4; // Q4 t2 submit t3 submit 分析： 可重复读是采用 MVCC 的方式来解决并发读写的问题（读取事务开始前的快照）。 UPDATE 会读取当前最新值（即使是在 REPEATABLE READ 下），但 SELECT 会读取快照。 Q1：t1 成功获取写锁并更新 b=2，但是还没提交。 Q2：t2 获取写锁失败，因此进入阻塞状态，等待 t1 释放锁。在 t1 提交后成功获取写锁并更新 b=3，但是还没提交。 Q3：t2 这时已经获取写锁，直接继续进行更新 b=4，但是还没提交。 Q4：t2 还未提交，t3 是 REPEATABLE READ 隔离级别（MVCC），会读取 t3 事务开始时的快照，也就是 t1 提交后的版本 b=2。b=4 是 t2 未提交的修改，t3 看不到，因此 Q4 查询不到任何数据。 mysql索引题：以下是各表执行频率高达90%的查询语句，为每个表的字段建立联合索引\n1 2 3 4 5 6 7 SELECT * FROM 表 WHERE a\u0026gt;1 AND b=2 // (b,a) SELECT * FROM 表 WHERE a=1 AND b=2 AND c\u0026gt;3 // (a,b,c), (b,a,c) SELECT * FROM 表 WHERE a=1 ORDER BY b // (a,b) SELECT * FROM 表 WHERE a=1 AND b=2 ORDER BY c // (a,b,c), (b,a,c) SELECT * FROM 表 WHERE a=1 AND b IN(1,2,3) // (a,b) SELECT * FROM 表 WHERE a=1 AND b=2 AND c IN(1,2,3) // (a,b,c), (b,a,c) SELECT * FROM 表 WHERE a=1 AND b IN(1,2,3) ORDER BY c // (a,b), (a,c) b 等值查询，a 范围查询\na 和 b 等值查询，c 范围查询\na 等值查询，b 排序（由于是 b+ 数结构，b 建立索引可以让叶子结点自动排好序，遍历所有叶子结点的这个链表就是排好序的）\na 和 b 等值查询，c 排序\nIN 查询是 OR，虽然 OR 不走索引，但是会这条语句会变成：(a=1 AND b=1) OR (a=1 AND b=2) OR (a=1 AND b=3)，所以 a 是等值查询，b 属于范围查询，可以建索引\na 和 b 等值查询，c IN（范围查询）\n如果是建 (a,b,c) 就会导致 b 范围查询之后 c 索引失效；如果是建 (a,c,b) 就会导致 c 排序之后 b 索引失效；所以只能选其中一个\n分析：联合索引设计原则\n最左前缀原则：MySQL 使用索引时，必须从最左列开始，不能跳过中间列。 等值查询优先：= 条件比 \u0026gt;、IN、ORDER BY 优先级更高，应该放在索引左侧。 范围查询放最后：\u0026gt;、\u0026lt;、BETWEEN、IN 等范围查询应尽量放在索引右侧，避免影响后续列的索引使用。 排序优化：如果查询包含 ORDER BY，尽量让排序字段在索引中，并且顺序与索引一致。 覆盖索引：如果查询只涉及索引列，可以避免回表，提高性能。 mysql优化器：优化器倾向于选择区分度高的列作为索引的前缀（调整查询条件的执行顺序）；如果 ORDER BY 的列在索引中且顺序一致可以避免 filesort 算法题：利用数组构建一个大小为 n 的双向队列，要求实现以下 6 个方法，且支持高并发下读多写少的情况：\n入队 出队 查询队尾元素 查询队头元素 返回队列是否为空 返回队列是否为满 分析：\n使用读写锁 ReentrantReadWriteLock：对于读是共享锁，写是排它锁 使用泛型提高复用性 成员变量用 private 修饰，方法用 public 修饰 灵活使用异常 辅助垃圾回收 这是一个容器类，不能用 static 静态属性修饰 只涉及设置临界区，不涉及同步机制 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 import java.util.concurrent.locks.ReentrantReadWriteLock; public class ConcurrentArrayDeque\u0026lt;T\u0026gt; { private final T[] array; private int head; // 队头指针 private int tail; // 队尾指针 private int count; // 元素数量 private final ReentrantReadWriteLock lock = new ReentrantReadWriteLock(); // 锁 private final ReentrantReadWriteLock.ReadLock readLock = lock.readLock(); // 读锁 private final ReentrantReadWriteLock.WriteLock writeLock = lock.writeLock(); // 写锁 public ConcurrentArrayDeque(int capacity) { // 构造方法 if (capacity \u0026lt;= 0) throw new IllegalArgumentException(\u0026#34;Capacity must be positive\u0026#34;); this.array = (T[]) new Object[capacity]; // 强制转换 this.head = 0; this.tail = 0; this.count = 0; } // 入队 (队尾)：写操作 public boolean offerLast(T item) { if (item == null) throw new NullPointerException(); writeLock.lock(); try { if (isFull()) return false; array[tail] = item; tail = (tail + 1) % array.length; count++; return true; } finally { writeLock.unlock(); } } // 出队 (队头)：写操作 public T pollFirst() { writeLock.lock(); try { if (isEmpty()) return null; T item = array[head]; array[head] = null; // 帮助GC head = (head + 1) % array.length; count--; return item; } finally { writeLock.unlock(); } } // 查询队头元素：读操作 public T peekFirst() { readLock.lock(); try { if (isEmpty()) return null; return array[head]; } finally { readLock.unlock(); } } // 查询队尾元素：读操作 public T peekLast() { readLock.lock(); try { if (isEmpty()) return null; return array[(tail - 1 + array.length) % array.length]; } finally { readLock.unlock(); } } // 队列是否为空：读操作 public boolean isEmpty() { readLock.lock(); try { return count == 0; } finally { readLock.unlock(); } } // 队列是否为满：读操作 public boolean isFull() { readLock.lock(); try { return count == array.length; } finally { readLock.unlock(); } } // 返回队列当前大小：读操作 public int size() { readLock.lock(); try { return count; } finally { readLock.unlock(); } } } class Test { public static void main() { ConcurrentArrayDeque\u0026lt;Integer\u0026gt; deque = new ConcurrentArrayDeque\u0026lt;\u0026gt;(5); // 生产者线程 new Thread(() -\u0026gt; { for (int i = 0; i \u0026lt; 10; i++) { boolean success = deque.offerLast(i); System.out.println(\u0026#34;Offer \u0026#34; + i + \u0026#34;: \u0026#34; + success); try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } } }).start(); // 消费者线程 new Thread(() -\u0026gt; { while (true) { Integer item = deque.pollFirst(); if (item != null) System.out.println(\u0026#34;Poll: \u0026#34; + item); try { Thread.sleep(150); } catch (InterruptedException e) { e.printStackTrace(); } } }).start(); } } ","date":"2025-04-21T00:00:00Z","permalink":"https://yees.com/p/%E9%9D%A2%E7%BB%8F/","title":"面经"}]